+++
draft = false
title = "API Definition Objects - In Depth"
date = 2014-07-29T10:56:22Z
[menu.sidebar_v1_6]
    parent = "management"
+++

Tyk handles APIs through files / objects called Definitions, these either sit in the `/etc/tyk/apps` directory or in a MongoDB collection.

An API Definition has many switches that change the way an incoming request is handled. It is possible to set too many options in a defintiton which can lead to unexpected behaviour.

With this in mind, we have split this section into the most common settings that are used together.

## Common elements

#### `id`
This is only used in the MongoDB context and bears no actual relation to the identity of the API

#### `name`
Human readable name of the API, is used for identification purposes but does not act as an index.

#### `api_id`
The identifier for the API, this should be unique, but can actually be any kind of string. for single-instance setups this can probably be set to 1. It is recommended to make this a UUID.

The api_id is used when querying the Tyk REST API for configuration details.

#### `org_id`
This is an identifier that can be set to indicate ownership of an API key or of an individual API. 

If the the Org ID is set (recommended), it is prepended to any Keys generated by Tyk - this enables lookups by prefixes from redis of keys that are in the system.

#### `active`
If set to `false` means that on start, restart or reload the API will be ignored and all paths and routes for that API will cease to be proxied. Any keys assigned ot it will still exist, though they will not be let through for that particular API.

#### `session_lifetime`

The session lifetime will override the expiry date if it has been set on a key (in seconds). for example, if a key has been created that never expires, then it will remain in the
session cache forever unless manually deleted. If a re-auth needs to be forced or a default expiry needs to be applied to all keys, then use this feature to set the session
expiry for an entire API.

## Authentication type flags
By default, Tyk will revert to a simple authentication token scheme unless these flags and their metadata are set (setting all of these to false will enable standard token mode).

This scheme basically means that you could send an authentication parameter and it's value (the api key) along with the request and Tyk will attach it to a session, just like a bearer token in OAuth or a session key in cookie-based setups.

However Tyk supports many more methods, and these can be set by enabling these flags (and their associated metadata)

### `use_keyless`

This will switch off all key checking and open the API definition up, some analytics will still be recorded, but rate-limiting, quotas and security policies will not be possible (there is no session to attach requests to).

this is a good setting for checking if Tyk works and is proxying traffic correctly.

*This method has no additional metadata settings*

### `use_basic_auth`

This method will enable basic auth as specified by the HTTP spec, an API with this flag set will request for a username and password and require a standard base64 Authentication header to be let thorugh.

Keys cannot be generated by tyk for this method and need to use the `/tyk/keys/add` method with the `basic_auth_data` metadata set in the keys session configuration (see [Basic Authentication](/access-control/basic-auth) and the overview of the Session Object in this use case under [Key Management](/rest-api/api-key-management)).

### `enable_signature_checking` a.k.a HMAC signing

If this option is set to `true`, Tyk will attempt to implement the HMAC singing standard as proposed in the [HTTP Signatures Spec](https://web-payments.org/specs/ED/http-signatures/2014-02-01/#page-3). In particular the structure of the Authorisation header and the encoding method need to be taken into account.

This method will use a session key to identify a user and a user secret that should be used by the client to sign each request's `date` header.

This method will also introduce clock skew checks, requests outside of 300ms of the system time will be rejected.

This method is not recommended for Single-Page-Webapps or Mobile apps due to the fact that secrets need to be distributed. 

### `hmac_allowed_clock_skew`

Set this value to anything larger than 0 to set the amount of milliseconds that will be tolerated for clock skew. Set to 0 to prevent clock skew checks on requests (only in HMAC mode).

### `use_oauth2`

Tyk attempts to implement a semi-seamless OAuth2 flow. Given the nature of OAuth2's three-party system, it is difficult to implement as a proxy without significantly compromising security or usability. 

Enabling this option will cause Tyk to add OAuth2-standard endpoints to the API for `/authorize` and `/token`, these will supersede any other requests to your proxied system in order to enable the flow.

Please see the [OAuth2 Flow](/access-control/oauth2) section for a comprehensive discussion of how to integrate with Tyk.

#### `oauth_meta.allowed_access_types`

Should be a string array of OAuth access options, types can be:

- `authorization_code` - client has an authorisation code to request a new access token
- `refresh_token` - client can use a refresh token to refresh expired bearer access token

**Note**: If using auth codes and refresh tokens, Tyk needs to notify your webapp of newly issued keys - it does this via web hook, please see the section on `notifications`.

#### `oauth_meta.allowed_authorize_types`

Should be a string array of OAuth authorisation types - options that are supported are:

- `code` - Client can request an authorization code which can be used to request an access code via a server request (traditionally reserved for server-side apps)
- `token` - Client can request an access token directly, this will not enable refresh tokens and all tokens have a 12 hour validity. Recommended for mobile apps and single-page webapps.

#### `oauth_meta.auth_login_redirect`

The Tyk OAuth flow has a dummy (intercept) `/authorize` endpoint which basically redirects the user to your login and authentication page, it will also send along all OAuth data as part of the request (so as to mimic a regular app flow).

This is the URL that the user will be sent to (via POST).

**Note**: This interface method is only supported by modern browsers that respect a [307 redirect](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection) (retaining method and data), and varies between browsers.

### `notifications`

When Tyk implements an OAuth2 flow, because it will handle access requests on your behalf once auth codes have been issued, it will need to notify your system that these have occured.

It will POST key data to the URL set in these options to ensure that your system is synchronised with Tyk.

#### `notifications.shared_secret`

POSTED data to your service will use this shared secret as an authorisation header, this is to ensure that messages being received are from Tyk and not from another system.

#### `notifications.oauth_on_keychange_url`

The URL that wil be sent the updated information - the URL will be polled up to 3 times if there is a communications failure. On a `200 OK` response it stops.

### `auth`

The auth section handles the standard Tyk authentication method, and if none of the above are set, will be the method used to authenticate requests.

#### `auth.use_param`

This will force Tyk to look for the `auth_header_name` value in the URL querystring parameters instead of in the header.

#### `auth.auth_header_name`

The header carrying the authentication token. Currently parameter-based authentication token passing is not supported.

## Versioning and Endpoint Handling

Tyk lets you version your API and apply access policies to versions, for example, if you have an API v1 that has a /widgets endpoint that is deprecated in v2, you can blacklist that endpoint so that requests to it are stopped before they hit your system.

In the same vein, you can white-list and ignore paths completely.

Version data can be transferred as either a header key or as a query parameter in all HTTP methods.

### `definition`

This section handles information related to where to look for the version key

#### `definition.location`

Can either be:

- `header`: Tyk will look for the version information in a header field (e.g. api-version: 1.2.3)
- `url-param` Tyk will check form and request parameters for a key matching the `definition.key` value.

#### `definition.key`

The name of the key to check for versioning information.

### `version_data`

Information relating to your actual version are stored here, if you do not wish to use versioning, use the `not_versioned` option and set up an entry called `Default` (see below).

### `version_data.not_versioned`

If set to `true` Tyk will skip version checking, you can still apply blacklist and white-list information to your API by specifying a `Default` version within the `versions` map

### `version_data.versions`

This is a keyed JSON object, in the form of:

	{
		"version-1": {
			"name": "version-1",
			"expires": "",
			"paths": {
				"ignored": [],
				"white_list": [],
				"black_list": []
			},
			"use_extended_paths": true,
			"extended_paths": {
			    "ignored": [],
                "white_list": [],
                "black_list": []
			}
		}
	}

Each version of your API should be defined here with a unique name, this name is what will be matched by `defintition.key`. Once Tyk has identified the API to load, and has 
allowed the access key through, it will check the access token's session data for access permissions. If it finds none, it will let the token through, however if there are 
permissions and versions defined, it will be strict in *only* allowing access to that version. For more information about handling access control, please see the 
[access control](/quotas-limits-security/access-control) section.


#### `version_data.{version-name}.expires`

The expires header, if set, will deprecate access to the API after the time specified. The entry here takes the form of: `"YYYY-MM-YY HH:MM"`. If this is not set the version will never expire.

#### `version_data.{version-name}.ignored` (legacy - deprecated)

This string array can define any paths (endpoints) in your API that should be ignored by Tyk, for example login, signup 
or any non-authenticated actions users can take. Specify these URL's here in the form of

    [
        "/user/login",
        "/user/signup"
    ]

Similar to other routers, matching is done on a first-come-first-served basis, ensure that specific paths are higher up the list than generic ones.

*Note:* It is possible to ignore non-generic paths using standard REST documentation markup, e.g. `/users/{user_id}/` will ignore `/users/12345/` and `/users/jively`, this is handy for cases where an entire sub-branch of a resource should be ignored (though each wildcard must be specified individually) Parameter names are arbitrary, and should be for reference only.

#### `version_data.{version-name}.white_list` (legacy - deprecated)

A string array of paths to white-list in your API, this is an explicit list of paths that are allowed access, any other endpoints, except those specified in 
`ignored_paths` will be refused access. Use this to enforce highly-specific access rules.

**Note:** White listing paths is exclusive, so black listed paths will not take effect.

#### `version_data.{version-name}.black_list` (legacy - deprecated)

The opposite of `white_list`, this will essentially block access to certain endpoints, this can be very handy if you are moving from a v1 to a v2 and have deprecated a path, simply define the deprecated 
path in the list and requests to it ith the new version header will be refused.

#### `version_data.{version-name}.use_extended_paths`

Set this value to `true` to use the new extended-paths feature, this will eventually become the default mode of operation.

Extended paths allow you to control which upstream paths are to be handled in a specific way (ignored, as part of white 
list or black list) by both path and method. The extended meta-data set also allow you to provide forced reply data to override 
or trap inbound requests for specific versions. This is very useful for mocking or slowly exposing a development API to a live 
upstream back end.

Each entry in the ignroed, black and white list lists have the same specification. The path specification 
has the following format:

    {
        "path": "{managed-path}",
        "method_actions": {
            "METHOD": {
                "action": "{action-code}",
                "code": {response-code},
                "data": "{body}",
                "headers": {
                    "{key}": "{value}"
                }
            }
        }
    }
    
You can set up the path to handle, and the action type, by default this should be set to `no_action` which means that Tyk will 
treat the path and method as-is without interference (i.e. if `no_action` is set, then `code`, `data`, `headers` and `body` are *not* used).

If you set `action` to `reply` Tyk will override the path and reply with settings defined in the remaining fields. This configuration can be 
used across all of the different path lists, and can be very useful when used in conjunction with the `white_list` access control list as
If it is used exclusively it can be used to mock out an entire API.

**Note: ** Any data that is placed in the 'data' section must be a string, not a JSON object (this could be a JSON string, for example).

#### `version_data.{version-name}.extended_paths.ignored`

This section will define methods and paths that will be ignored and will bypass the quota and rate limiting machinery of Tyk.

An example entry:
    
    ...
    "ignored": [
        {
            "path": "/v1/ignored/literal",
            "method_actions": {
                "GET": {
                    "action": "no_action",
                    "code": 200,
                    "data": "",
                    "headers": {}
                }
            }
        },
        {
            "path": "/v1/ignored/with_id/{id}",
            "method_actions": {
                "GET": {
                    "action": "reply",
                    "code": 200,
                    "data": "Hello World\n",
                    "headers": {
                        "x-tyk-override": "tyk-override",
                    }
                }
            }
        }
    ], ...

#### `version_data.{version-name}.extended_paths.black_list`

This section defines methods and paths that will be blocked by Tyk.

An example entry:
    
    ...
    "black_list": [
        {
            "path": "v1/disallowed/blacklist/literal",
            "method_actions": {
                "GET": {
                    "action": "no_action",
                    "code": 200,
                    "data": "",
                    "headers": {}
                }
            }
        },
        {
            "path": "v1/disallowed/blacklist/{id}",
            "method_actions": {
                "GET": {
                    "action": "reply",
                    "code": 200,
                    "data": "Not allowed buddy \n",
                    "headers": {
                        "x-tyk-override-test": "tyk-override"
                    }
                }
            }
        }
    ], ...

#### `version_data.{version-name}.extended_paths.white_list`

This section defines methods and paths that are exclusively allowed through by Tyk. Use this section to 
define an entire mock API as well as this will force a specific URL structure (and block all other paths) 
while replying to all requests, therefore never sending any requests upstream.

An example entry:
    
    ...
    "white_list": [
        {
            "path": "v1/allowed/whitelist/literal",
            "method_actions": {
                "GET": {
                    "action": "no_action",
                    "code": 200,
                    "data": "",
                    "headers": {}
                }
            }
        },
        {
            "path": "v1/allowed/whitelist/reply/{id}",
            "method_actions": {
                "GET": {
                    "action": "reply",
                    "code": 200,
                    "data": "flump  \n",
                    "headers": {
                        "x-tyk-override-test": "tyk-override"
                    }
                }
            }
        },
        {
            "path": "v1/allowed/whitelist/{id}",
            "method_actions": {
                "GET": {
                    "action": "no_action",
                    "code": 200,
                    "data": "",
                    "headers": {}
                }
            }
        },
        {
            "path": "/tyk/rate-limits/",
            "method_actions": {
                "GET": {
                    "action": "no_action",
                    "code": 200,
                    "data": "",
                    "headers": {}
                }
            }
        }
    ], ...

You'll notice we've included the end user rate-limit check URL as a white listed path, if you dont do this, 
Tyk will block access to this URL.

#### `version_data.{version-name}.extended_paths.cache`

If the cache is enabled (see `cache_options`), then these paths will be cached. Caching is applied on all sae methods (GET, OPTIONS and HEAD), caching cannot be controlled on a per-method basis.

A sample entry would be:

    ...
    "cache": [
        "widgets/{widgetID}",
        "widgets",
        "foobars/{foobarID}",
        "foobars"
    ], ...
    
### `version_data.{version-name}.extended_paths.transform`

This section determines which paths are to have a template applied to them in order to transform the body data in the request to another structure. Currently on JSON body data is supported as
an input, however the template can output to any format, as it uses Golang templates so structure of outbound data is highly configurable.

    ...
    "transform": [
        {
            "path": "widget/{id}",
            "method": "POST"
            "template_data": {
                "template_mode": "file",
                "template_source": "./templates/transform_test.tmpl"
            }
        }
    ], ...


#### `version_data.{version-name}.extended_paths.transform.path`

This is the path to apply the template to.

#### `version_data.{version-name}.extended_paths.transform.method`

This is the method to apply the template to

#### `version_data.{version-name}.extended_paths.transform.template_data.template_mode`

Can be either `file` or `blob`. Setting this to `file` will have Tyk try to load the path and parse the template from a file set in `template_source`. Setting this to `blob` enables the template to be
embedded in the definition, e.g. if Tyk is pulling configurations from a database. Embedded templates must be Base64 encoded strings and placed in the `template_source` field.

#### `version_data.{version-name}.extended_paths.transform.template_data.template_source`

The file, or base64-encoded lob that will be used as a template to perform the transfomration.

### `version_data.{version-name}.extended_paths.transform_headers`

Elements specified in this list will have their headers modified according to the rules set out in the path meta settings.

Entries look like this:

    "transform_headers": [
        {
            "delete_headers": ["Content-Type", "authorization"],
            "add_headers": {"x-tyk-test-inject": "new-value"},
            "path": "widgets/{id}",
            "method": "GET"
        }
    ]

#### `version_data.{version-name}.extended_paths.transform_headers.delete_headers`

Tyk will remove these headers from a request if it is processed.

#### `version_data.{version-name}.extended_paths.transform_headers.add_headers`

Tyk will add the headers and values specified in this list, deletions happen before additions, so modifying headers that already exist is possible by specifying the same key in delte and add.

#### `version_data.{version-name}.extended_paths.transform_headers.path`

The path that the header injection will be applied to

#### `version_data.{version-name}.extended_paths.transform_headers.path`

The method for this path that the injection will be applied to.

## `proxy`

The proxy section outlines the actual API proxying functionality, here you can define where Tyk should listen, and where Tyk should proxy traffic to.

### `proxy.listen_path`

The path to listen on, e.g. `/api` or `/`, any requests coming into the host, on the port that Tyk is configured to run on, that go to this path will have the rules 
defined in the API Definition applied. Versioning assumes that different versions of an API will live on the same URL structure. If you are using URL-based versioning 
(e.g. `/v1/function`, `/v2/function/` then it is recommended to set up a separate non-versioned Definition for each version as they are essentially separate APIs.

Proxied requests are literal, no re-writing takes place, fo example, if a request is sent to the listen path of: `/listen-path/widgets/new` and the URL to proxy to is
`http://your.api.com/api/` then the *actual* request that will land at your service will be: `http://your.api.com/api/listen-path/widgets/new`.

this behaviour can be circumvented so that the `listen_path` is stripped from the outgoing request. See the section on `strip_listen_path` below.

### `proxy.target_url`

This defines the target URL that the request should be proxied to if it passes all checks in Tyk.

### `proxy.strip_listen_path`

By setting this to `true`, Tyk will attempt to replace the listen_path in the outgoing request with an empty string - this means that in the above scenario where 
`/listen-path/widgets/new` and the URL to proxy to is `http://your.api.com/api/` becomes `http://your.api.com/api/listen-path/widgets/new`, actually
changes the outgoing request to be: `http://your.api.com/api/widgets/new`. 

## IP White-listing (Middleware)

### `enable_ip_whitelisting`

If set to `true`, only requests coming from the explicit list of IP addresses (`allowed_ips`) are allowed through.

## `allowed_ips`

A list of strings that defines the IP addresses that are allowed access via Tyk. This list is explicit and wildcareds are currently not supported. e.g.:

    ...
    "enable_ip_whitelisting": true,
    "allowed_ips": ["12.12.12.12", "12.12.12.13", "12.12.12.14"]
    ...

## Batch Requests

Tyk now supports request batching, so a client only makes a single request to the API but gets a compound response object back. 

To enable batch-request support, set the `enable_batch_request_support` value to `true`

This is especially handy if clients have complex requests that hav multiple synchronous dependencies and do not wish to have the entire request / response cycle 
running for each event. 

Batch requests that come into Tyk are *run through the whole tyk machinery* and *use a relative path to prevent spamming*, this means that a batch request to 
Tyk for three resources with the same API key will have three requests applied to their session quota and request limiting could become active if they are being throttled.

Tyk reconstructs the API request based on the data in the batch request, this is to ensure that Tyk is not being used to proxy requests to other hosts outside of the upstream
API being accessed.

Batch requests are created by POSTing to the /{api-id}/tyk/batch endpoint, these requests **do not require a valid key**, but their request list does, 
here is a sample request body:

    {
        "requests": [
            {
                "method": "GET",
                "headers": {
                    "x-tyk-test": "1",
                    "x-tyk-version": "1.2",
                    "authorization": "1dbc83b9c431649d7698faa9797e2900f"
                },
                "body": "",
                "relative_url": "get"
            },
            {
                "method": "GET",
                "headers": {
                    "x-tyk-test": "2",
                    "x-tyk-version": "1.2",
                    "authorization": "1dbc83b9c431649d7698faa9797e2900f"
                },
                "body": "",
                "relative_url": "get"
            }
        ],
        "suppress_parallel_execution": false
    }

the response will will be a structured reply that encapsulates the responses for each of the outbound requests. If `suppress_parallel_execution` is set to `true`, 
requests will be made synchronously, if set to `false` then they will run in parallel and the response order is not guaranteed.

A response to the above when pointing at the httpbin(1) would look like:

    [
        {
            "relative_url": "get",
            "code": 200,
            "headers": {
                "Access-Control-Allow-Credentials": [
                    "true"
                ],
                "Access-Control-Allow-Origin": [
                    "*"
                ],
                "Content-Length": [
                    "497"
                ],
                "Content-Type": [
                    "application/json"
                ],
                "Date": [
                    "Wed, 12 Nov 2014 15:32:43 GMT"
                ],
                "Server": [
                    "gunicorn/18.0"
                ],
                "Via": [
                    "1.1 vegur"
                ]
            },
            "body": "{\n  \"args\": {}, \n  \"headers\": {\n    \"Accept-Encoding\": \"gzip\", \n    \"Authorization\": \"1dbc83b9c431649d7698faa9797e2900f\", \n    \"Connect-Time\": \"2\", \n    \"Connection\": \"close\", \n    \"Host\": \"httpbin.org\", \n    \"Total-Route-Time\": \"0\", \n    \"User-Agent\": \"Go 1.1 package http\", \n    \"Via\": \"1.1 vegur\", \n    \"X-Request-Id\": \"6a22499a-2776-4aa1-80c0-686581a8be4d\", \n    \"X-Tyk-Test\": \"2\", \n    \"X-Tyk-Version\": \"1.2\"\n  }, \n  \"origin\": \"127.0.0.1, 62.232.114.250\", \n  \"url\": \"http://httpbin.org/get\"\n}"
        },
        {
            "relative_url": "get",
            "code": 200,
            "headers": {
                "Access-Control-Allow-Credentials": [
                    "true"
                ],
                "Access-Control-Allow-Origin": [
                    "*"
                ],
                "Content-Length": [
                    "497"
                ],
                "Content-Type": [
                    "application/json"
                ],
                "Date": [
                    "Wed, 12 Nov 2014 15:32:43 GMT"
                ],
                "Server": [
                    "gunicorn/18.0"
                ],
                "Via": [
                    "1.1 vegur"
                ]
            },
            "body": "{\n  \"args\": {}, \n  \"headers\": {\n    \"Accept-Encoding\": \"gzip\", \n    \"Authorization\": \"1dbc83b9c431649d7698faa9797e2900f\", \n    \"Connect-Time\": \"7\", \n    \"Connection\": \"close\", \n    \"Host\": \"httpbin.org\", \n    \"Total-Route-Time\": \"0\", \n    \"User-Agent\": \"Go 1.1 package http\", \n    \"Via\": \"1.1 vegur\", \n    \"X-Request-Id\": \"1ab61f50-51ff-4828-a7e2-17240385a6d2\", \n    \"X-Tyk-Test\": \"1\", \n    \"X-Tyk-Version\": \"1.2\"\n  }, \n  \"origin\": \"127.0.0.1, 62.232.114.250\", \n  \"url\": \"http://httpbin.org/get\"\n}"
        }
    ]

With the body for each request string encoded in the `body` field.

## `expire_analytics_after`

If you are running a busy API, you may want to ensur that your MongoDB database does not overflow with od data. Set the `expire_analytics_after` value to the number of seconds you ould like the data to last for. Setting this flag to anything above 0 will set an `expireAt` field for each record that is written to the database. 

**Important:** Tyk will not create the expiry index for you, in order to implement data expiry for your analytics data, ensure that the index is created, this is very easily achieved using the mongoDB command line interface [as described here](http://docs.mongodb.org/manual/tutorial/expire-data/).

## `dont_set_quota_on_create` (default false)

If this is set to `true`, when the API is used to edit, create or add keys, the quota cache in Redis will not be re-set. By default, all updates or creates to Keys that have Quotas set will re-set the quota (This has been the default behaviour since 1.0). 

This behaviour can be bypassed on a case-by-case basis by using the `suppress_reset` parameter when making a REST API request, this is the advised mode of operation as it allows for manual, granular control over key quotas and reset timings.

## `cache_options`

This section enables you to configure the caching behaviour of Tyk and to enable or disable the caching middleware for your API.

### `cache_options.enable_cache`

Set this value to true i the cache should be enabled for this endpoint, setting it to false will stop all caching behaviour.

### `cache_options.cache_timeout`

The amount of time, in seconds, to keep cached objects, defaults to 60 seconds.

### `cache_options.cache_all_safe_requests`

Set this to `true` if you want all *safe* requests (GET, HEAD, OPTIONS) to be cached, this is a blanket setting for APIs where caching is required but you don't want to set individual paths up
in the definition.

### `cache_options.enable_upstream_cache_control`

Set this to true if you want your application to control the cache options for Tyk (TTL and Whether to cache or not). See the caching section for implementation details.

